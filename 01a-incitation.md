---
outline: deep
---

# Incitation

## Amener les utilisateurs Ã  effectuer des actions spÃ©cifiques

Voyons par l'exemple d'une interrogation, puis par la suggestion d'une solution
logique:

> **Je voudrais que les utilisateurs viennent sur mon site.**

- Pourquoi ?
- Parce que sur mon site il y a des informations intÃ©ressantes que je voudrais
  qu'ils lisent.
- Avez-vous pensÃ© Ã  mettre en place des mesures SEO (rÃ©fÃ©rencement naturel,
  amÃ©lioration de la visibilitÃ© sur les moteurs de recherche) ?

---

> **Je voudrais que les utilisateurs crÃ©ent un compte sur mon site.**

- Mais pourquoi vos utilisateurs le feraient-ils ?
- Mais parce qu'ils en ont besoin pour que je leur envoie ce qu'ils me demandent
  : des produits qu'ils achÃ¨tent.
- Eh bien explique leur que pour qu'ils puissent recevoir les produits, ils faut
  qu'ils donnent leur nom, prÃ©nom, email, telephone, et adresse de livraison,
  puis que pour ne pas rÃ©pÃ©ter le process d'inscription, tu peux mÃ©moriser cela
  sur un compte qu'ils crÃ©ent.
- Je pense qu'ils ont compris mais ils ne voient pas comment faire pour crÃ©er un
  compte.
- Sur quelle page sont ils lorsqu'ils se demandent cela ?
- Ils viennent de cliquer sur "Commander" dans la page du panier.
- Eh bien, Ã  ce moment lÃ , il faut mettre dans leur champ visuel un bouton de
  "crÃ©ation de compte", ou mÃªme carrÃ©ment un formulaire de crÃ©ation de compte !

Sur ces deux exemples, on peut constater que la solution vient naturellement si
on s'interroge **qui est l'utilisateur**, et surtout **quel est son objectif**,
ses attentes en venant sur le logiciel.

Si on comprend ce que cherche Ã  faire l'utilisateur Ã  tout moment de
l'utilisation, alors les Ã©crans peuvent devenir beaucoup plus simples : ils ne
montrent que ce que l'utilisateur attend, et pas autre chose.

Encore mieux : l'utilisateur peut se passer de comprendre certains aspects du
mÃ©tier lorsque on ne lui laisse pas le choix de faire des Â« bÃªtises Â», c'est Ã 
dire lorsque l'interface le **guide**.

::: tip ğŸ˜Š Questions Ã  se poser

- C'est qui l'utilisateur ? Il vient faire quoi ?
- Est ce qu'il comprend par oÃ¹ il faut commencer sur le premier Ã©cran ?
- Et ensuite il fait quoi ? Et pourquoi l'utilisateur va t'il continuer ?
- Y a t'il pas des choses Ã  l'Ã©cran inutiles pour ce que l'utilisateur vient
  faire ?

:::

## Les alternatives, les choix, en fonction des Ã©tats ou des contextes

Un logiciel doit pouvoir faire face en gÃ©nÃ©ral Ã  de multiples utilisateurs, avec
des objectifs diffÃ©rents. Un mÃ©tier est ce qu'il est. Et il est parfois complexe
et ne peut Ãªtre rÃ©duit
([Loi de Tesler](https://ux-lois.github.io/cards/03-law-tesler/)).

Ce n'est pas pour autant que les Ã©crans doivent Ãªtre complexes, notamment
lorsque l'utilisateur doit faire des choix.

::: tip ğŸ˜Š Astuces

1. Eviter de faire choisir l'utilisateur mais le mettre en situation de accepter
   ou refuser une proposition.
2. Eviter de faire des questions avec des boutons OUI/NON
3. Appliquer la loi de Fitts :

- PrÃ©fÃ©rer les boutons qui contourent le choix plutÃ´t que les cases Ã  cocher ou
  les boutons radio
- Si boutons radio ou case Ã  cocher alors agrandir les surfaces cliquables

4. Mettre en valeur un choix parmi des boutons secondaires avec un bouton
   primaire.
5. Utiliser un bouton "etcetera" pour mettre des choix rares en retrait.
6. Ne faire apparaitre les questions suivantes aprÃ¨s que l'utilisateur ait
   rÃ©pondu aux questions prÃ©cÃ©dentes. C'est le principe de la "progressive
   disclosure"

:::

## Informations, aides permettant de savoir dans quel Ã©tat, contexte l'utilisateur se trouve par rapport Ã  son objectif.

En gÃ©nÃ©ral, il est nÃ©cessaire que l'utilisateur sache toujours oÃ¹ il en est, et
que le reste Ã  faire ne soit pas pÃ©nible Ã  identifier sur l'interface et ne
paraisse pas difficile Ã  achever.

::: tip ğŸ˜Š A vÃ©rifier

1. Lorsque l'utilisateur parcours plusieurs Ã©crans techniques diffÃ©rents, un
   [fil d'ariane](https://www.redacteur.com/blog/wordpress-fil-ariane-site-web/)
   dans l'entÃªte du site l'aide Ã  savoir oÃ¹ il en est.
2. A la fin d'un processus, ne pas oublier de rÃ©compenser l'utilisateur. C'est
   [la rÃ¨gle pic-fin](https://ux-lois.github.io/cards/98-peak-end-rule/).
3. Un bouton qui fait une action longue, devrait se dÃ©sactiver et indiquer avec
   une animation (ex: spinner) que la partie non visible du logiciel est entrain
   de faire une action longue. Voir Ã  cet effet la rÃ¨gle du
   [goal gradient effect](https://ux-lois.github.io/cards/02-effect-goal-gradient/).
4. Un bouton de validation de formulaire devrait faire l'un ou l'autre en cas de
   champ mal rempli :
   - soit se dÃ©sactiver pour interdire la soumission
   - soit Ì‚Ãªtre actif et servir de dÃ©bogueur en scrollant vers le champ mal
     rempli.
5. Un champ de saisie mal rempli devrait avoir un message d'erreur.
6. Un message d'erreur ne devrait pas provoquer de
   [Cumulative Layout Shift](https://web.dev/articles/cls?hl=fr).
7. Eviter les champs de saisie libre. Essayer de trouver un Ã©quivalent qui
   permet une saisie uniquement en cliquant sur des boutons (ex: Calendrier,
   sÃ©lecteur de quantitÃ©). On l'appelle ici un **champ de saisie guidÃ©**.
8. Lorsque l'utilisateur arrive sur un formulaire, mettre le focus sur le
   premier champ du formulaire.
9. Lorsque un champ de saisie guidÃ© est complÃ©tÃ©, il est recommandÃ© de mettre le
   focus sur le suivant pour inviter l'utilisateur dans sa saisie.

:::

## Moyens d'accessibilitÃ© permettant Ã  l'utilisateur d'atteindre son objectif.

Aujourd'hui, l'accessibilitÃ© est devenue un sujet juridique. En France par
exemple, on peut se rÃ©fÃ©rer au
[RGAA et ses critÃ¨res d'accessibilitÃ©](https://accessibilite.numerique.gouv.fr/methode/criteres-et-tests/)
pour amÃ©liorer l'accessibilitÃ© de son logiciel.
